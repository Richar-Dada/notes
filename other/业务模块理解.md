# 模块
1. 每个模块只做好一件事
2. 越底层的模块，越抽象，越具有高复用度
3. 按照架构的层数从上到下依赖，不要出现下层模块依赖上层模块的现象
4. 模块自完备性，意思就是自己是独立的个体，能够独立完成功能

# 模块化优缺点
优点--代码复用，功能复用，业务隔开，版本风险控制
缺点--增加沟通成本，降低开发周期，而且对开发人员能力要求高

# 模块解耦与通信
1. 公共模块下沉--一些多处用到的模块可以抽象成底层模块，通过添加一些API与其他模块通信

>解耦--就是将程序积木化，像我们玩的积木一样，各个积木可以组合在一起而形成一个形状，又可以拆分，又可以替换，因为基本上 各个积木块都是独立的，只要他们之间的接口（形状）匹配，就可以灵活地组合在一起。


# RequireJS 与 SeaJS 的异同
RequireJS 和 SeaJS 都是模块加载器，倡导的是一种模块化开发理念，核心价值是让 JavaScript的模块化开发变得更简单自然。 不同之处：

1. 定位有差异。RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino / Node 等环境的模块加载器。SeaJS 则专注于 Web 浏览器端，同时通过 Node 扩展的方式可以很方便跑在 Node 服务器端。
2. 遵循的规范不同。RequireJS 遵循的是 AMD（异步模块定义）规范，SeaJS 遵循的是 CMD （通用模块定义）规范。规范的不同，导致了两者 API 的不同。SeaJS 更简洁优雅，更贴近 CommonJS Modules/1.1 和 Node Modules 规范。
3. 社区理念有差异。RequireJS 在尝试让第三方类库修改自身来支持 RequireJS，目前只有少数社区采纳。SeaJS 不强推，采用自主封装的方式来“海纳百川”，目前已有较成熟的封装策略。
4. 代码质量有差异。RequireJS 是没有明显的 bug，SeaJS 是明显没有 bug。
5. 对调试等的支持有差异。SeaJS 通过插件，可以实现 Fiddler 中自动映射的功能，还可以实现自动 combo 等功能，非常方便。RequireJS 无这方面的支持。
